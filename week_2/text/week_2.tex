\documentclass[12pt]{article}
\usepackage[left=1in, right=1in]{geometry}

\usepackage{url}

%\usepackage{arydshln}

\usepackage{graphicx}

\usepackage{color}
\definecolor{light-gray}{gray}{0.30}

\usepackage{listings}
\lstset{
	frame=leftline,
	frameround=ttff,
	numbers=left,
	language=C++,
	showstringspaces=False,
	extendedchars=False,
	numberstyle=\footnotesize,
	basicstyle=\small\ttfamily,
	commentstyle=\color{light-gray}\slshape,
	belowskip=1.5em,
	aboveskip=1.5em,
	fontadjust,
	tabsize=4,		%added for proper tab alligning
	xleftmargin=0cm,
	xrightmargin=0cm
}


\newcommand{\desc}[1]{\textit{#1} \vspace{1em}}

\title{\itshape Exercises week 2}

\author{
	Klaas Isaac Bijlsma \\ s2394480
	\and
	David Vroom \\ s2309939
}

\date{\today}

\begin{document}
\maketitle

\section*{Exercise 11}
\desc{}


\clearpage
\section*{Exercise 12}
\desc{Study the way \texttt{delete[]} works}

We used the following code,

\lstinputlisting[title=\texttt{maxfour/maxfour.h}]{../ex12/maxfour/maxfour.h}
\lstinputlisting[title=\texttt{maxfour/maxfour.ih}]{../ex12/maxfour/maxfour.ih}
\lstinputlisting[title=\texttt{maxfour/data.cc}]{../ex12/maxfour/data.cc}
\lstinputlisting[title=\texttt{maxfour/destructor.cc}]{../ex12/maxfour/destructor.cc}
\lstinputlisting[title=\texttt{main.ih}]{../ex12/main.ih}
\lstinputlisting[title=\texttt{main.cc}]{../ex12/main.cc}

%\lstinputlisting[title=\texttt{Output of main4.cc},language=bash, numbers=none]{../ex12/outputex12.txt}

\textbf{Explain why the solution is so simple}\\
The solution is so simple because when an exception is thrown during the construction of an array of 10 Maxfour objects, stack unwinding will destroy the already allocated objects. No explicit call of the destructor is needed. Furthermore we do not need to keep track of the already allocated objects. 

\clearpage
\section*{Exercise 13}
\desc{}

\clearpage
\section*{Exercise 14}
\desc{}


\clearpage
\section*{Exercise 15}
\desc{}

\clearpage
\section*{Exercise 16}
\desc{Learn how to end a program safely}

\textbf{How do you end a program in such a situation?}

In main wordt een object geconstruct en een functie aangeroepen die throwt. Deze functie doet vervolgens hetzelfde net als de functie daar weer in. In het diepste nested level wordt de throw operator daadwerkelijk aangeroepen, de exception gethrowd en vervolgens gerethrowd. Zodra de exception gethrowd wordt en de exception het try-block verlaat, wordt de destructor aangeroepen, net als in de levels daarboven.
Op deze manier worden alle constructed objects netjes vernietigd.\\

De volgende code verduidelijkt dit,

\lstinputlisting[title=\texttt{demo/demo.h}]{../ex16/demo/demo.h}
\lstinputlisting[title=\texttt{demo/demo.ih}]{../ex16/demo/demo.ih}
\lstinputlisting[title=\texttt{demo/demo.cc}]{../ex16/demo/demo.cc}
\lstinputlisting[title=\texttt{demo/destructor.cc}]{../ex16/demo/destructor.cc}
\lstinputlisting[title=\texttt{main.ih}]{../ex16/main.ih}
\lstinputlisting[title=\texttt{main.cc}]{../ex16/main.cc}
\lstinputlisting[title=\texttt{function1.cc}]{../ex16/function1.cc}
\lstinputlisting[title=\texttt{function2.cc}]{../ex16/function2.cc}
\lstinputlisting[title=\texttt{function3.cc}]{../ex16/function3.cc}

\clearpage
\section*{Exercise 17}
\desc{Learn to understand how throw lists and noexept work}

A small class \texttt{ShowExcepts} is made. It has a constructor and two functions \texttt{asAthrowList()} and \texttt{asNoexcept()}, that behave as if \texttt{throw (int, std::string)} or the keyword \texttt{noexcept} is specified, respectively, while this is not actually specified. When this would be speciefied, the compiler generates additional code, and this code is now already provided by us, thus simualiting the use of the specifications. 
The two member functions call a function \texttt{test()}, which prints that it is called and throws an exception (below the code, the output is discussed when this exception is an int or a double). 


\lstinputlisting[title=\texttt{showexcepts/showexcepts.h}]{../ex17/showexcepts/showexcepts.h}
\lstinputlisting[title=\texttt{showexcepts/showexcepts.ih}]{../ex17/showexcepts/showexcepts.ih}
\lstinputlisting[title=\texttt{showexcepts/showexcepts1.cc}]{../ex17/showexcepts/showexcepts1.cc}
\lstinputlisting[title=\texttt{showexcepts/asathrowlist.cc}]{../ex17/showexcepts/asathrowlist.cc}
\lstinputlisting[title=\texttt{showexcepts/asnoexcept.cc}]{../ex17/showexcepts/asnoexcept.cc}
\lstinputlisting[title=\texttt{main.ih}]{../ex17/main.ih}
\lstinputlisting[title=\texttt{main.cc}]{../ex17/main.cc}
\lstinputlisting[title=\texttt{test.cc}]{../ex17/test.cc}

If \texttt{test()} throws a double (e.g. 1.5), the output shown below is produced. In \texttt{asathrowlist}, the double is not caught by the int or string catcher, but by the catch-all, throwing a \texttt{bad\_exception}. 

In the second try block, \texttt{asnoexcept} is called, which calls \texttt{std::terminate()}, terminating the program. Therefore, the cout statement in \texttt{main}'s final catch clause is not reached. 

\lstinputlisting[title={Output when \texttt{test()} throws a double (1.5)},language=bash, numbers=none]{../ex17/outputDouble.txt}

If \texttt{test()} throws an int (e.g. 1), the output shown below is produced. In \texttt{asathrowlist}, the int is caught by the int catcher, and then rethrown. In \texttt{main}, it is then caught by the catch-all handler, giving the shown output. 

\lstinputlisting[title={Output when \texttt{test()} throws an int (1)},language=bash, numbers=none]{../ex17/outputInt.txt}



\clearpage
\section*{Exercise 18}
\desc{Learn to identify points where exceptions may be thrown}
See 10.10 Annotations ;-)

\clearpage
\section*{Exercise 19}
\desc{}


\clearpage
\end{document}
