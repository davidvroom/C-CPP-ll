\documentclass[12pt]{article}
\usepackage[left=1in, right=1in]{geometry}

\usepackage{url}

%\usepackage{arydshln}

\usepackage{graphicx}

\usepackage{color}
\definecolor{light-gray}{gray}{0.30}

\usepackage{listings}
\lstset{
	frame=leftline,
	frameround=ttff,
	numbers=left,
	language=C++,
	showstringspaces=False,
	extendedchars=False,
	numberstyle=\footnotesize,
	basicstyle=\small\ttfamily,
	commentstyle=\color{light-gray}\slshape,
	belowskip=1.5em,
	aboveskip=1.5em,
	fontadjust,
	tabsize=4,		%added for proper tab alligning
	xleftmargin=0cm,
	xrightmargin=0cm
}


\newcommand{\desc}[1]{\textit{#1} \vspace{1em}}

\title{\itshape Exercises week 1}
%\subtitle{C/C++ course part II - }

\author{
	Klaas Isaac Bijlsma \\ s2394480
	\and
	David Vroom \\ s2309939
}

\date{\today}

\begin{document}
\maketitle

\section*{Exercise 1}
\desc{Attain some familiarity with the way functions are selected from namespaces}

We used the following code,
\lstinputlisting[title=\texttt{main.cc}]{../ex1/main.cc}

\textbf{Call fun and explain why \texttt{First::fun} is called. How would you call \texttt{Second::fun} instead?}\\
\\
Als een functie uit een namespace wordt aangeroepen zonder de namespace te speciferen, dan wordt de namespace van het argument van de functie gebruikt om de namespace van de functie te bepalen; het zogenaamde 'Koenig Lookup'. Aangezien het argument is gedeclareerd als type \texttt{First::Enum} wordt \texttt{First::fun} aangeroepen. Om \texttt{Second::fun} aan te roepen moet de namespace expliciet worden genoemd: \texttt{Second::fun(symbol)}.\\

\textbf{In the namespaces slides (\#6) it is stated that \texttt{operator<<}'s use is simplified because of the Koenig lookup. Explain.}\\
\\
Zonder Koenig lookup zal de korte versie \texttt{std::cout << "Hello"} (net als de lange versie \texttt{operator<<(std::cout, "Hello")}) niet gebruikt kunnen worden. De insertion operator functie uit de standard namespace is dan niet bereikbaar zonder explicite functie call \texttt{std::operator<<(std::cout, "Hello")} voor zowel de korte als de lange versie.\\

\textbf{Now, just above main, declare a function \texttt{void fun(First::Enum symbol)}. Compile this program. What happens? Why?}\\
\\
Er ontstaat een foutmelding vanwege ambiguititeit. De compiler weet nu niet of hij de functie uit de namespace \texttt{First} of de globale functie net boven main moet aanroepen.


\clearpage
\section*{Exercise 2}
\desc{Learn why streams can be used to determine the truth values of conditions, but not to assign values to bool variables.}

Note: The code given in the exercise is incomplete, and therefore won't compile even without the intended mistake. So first of all we state the following code as a starting point:

\lstinputlisting[title=\texttt{header.ih}]{../ex2/1/header.ih}
\lstinputlisting[title=\texttt{main.cc}]{../ex2/1/main.cc}
\lstinputlisting[title=\texttt{process.cc}]{../ex2/1/process.cc}
\lstinputlisting[title=\texttt{promptget.cc}]{../ex2/1/promptget.cc}


\textbf{1. Why doesn't this work? (Explain why the error message is generated by the compiler)}\\
This code doesn't work, because \texttt{getline(in, str)} cannot be returned as a bool in \texttt{promptGet}. This is because the class \texttt{istream} defines \texttt{explicit operator bool() const}. This allows the compiler to only perform a conversion to a bool when this is explicitly required (as in a while statement), but not implicitly (as in the return statement above).\\

\textbf{2. Change \texttt{promptGet}'s body so that the code does compile.}\\
By changing \texttt{promptGet}'s body in the following way, the code does compile:
\lstinputlisting[title=\texttt{promptget.cc}]{../ex2/2/promptget.cc}

\textbf{3. Without changing \texttt{promptGet}'s body, change \texttt{promptGet} so that the code does compile.}\\
By changing \texttt{promptGet} (and the declaration in the internal header) in the following way, the code does compile:
\lstinputlisting[title=\texttt{promptget.cc}]{../ex2/3/promptget.cc}




\clearpage
\section*{Exercise 3}
\desc{Learn to implement index operators}

The Matrix class that is used here, is derived from the solutions of excercise 64. Extensions to the class header made in upcoming exercises are also shown here. \\

We used the following code,
\lstinputlisting[title=\texttt{matrix/matrix.h}]{../ex7/matrix/matrix.h}

\clearpage
\section*{Exercise 4}
\desc{Learn to implement and spot opportunities for overloaded operators}

The header is shown in exercise 3, the implementations of the added functions are shown below:
\lstinputlisting[title=\texttt{matrix/add.cc}]{../ex7/matrix/add.cc}
\lstinputlisting[title=\texttt{matrix/operatoradd1.cc}]{../ex7/matrix/operatoradd.cc}
\lstinputlisting[title=\texttt{matrix/operatoradd2.cc}]{../ex7/matrix/operatoradd2.cc}
\lstinputlisting[title=\texttt{matrix/operatorcompadd1.cc}]{../ex7/matrix/operatorcompadd1.cc}
\lstinputlisting[title=\texttt{matrix/operatorcompadd2.cc}]{../ex7/matrix/operatorcompadd2.cc}

\clearpage
\section*{Exercise 5}
\desc{Learn to insert/extract objects of your own class}

\textbf{Explain why implementing the extraction operator when using compilers that do \emph{not} implement the c++-17 standard is more complex than implementing the extraction operators when using compilers that \emph{do} implement the c++-17 standard}\\\\
We don't know the answer to this question, and also could not find it in the lecture, annotations and the internet.\\
Also, we are aware that simply calling \texttt{mat(2,5)} does invalidate \texttt{mat}'s data with our code. We thought of making a proxy class and use a conversion operator to solve this, but we couldn make it work. We would like some advice on this. However, the overloaded extraction and insertion operator of the Matrix object work properly.\\
The header is shown in exercise 3, the implementations of the added functions are shown below. 
\lstinputlisting[title=\texttt{matrix/extractcols.cc}]{../ex7/matrix/extractcols.cc}
\lstinputlisting[title=\texttt{matrix/extractrows.cc}]{../ex7/matrix/extractrows.cc}
\lstinputlisting[title=\texttt{matrix/functor1.cc}]{../ex7/matrix/functor1.cc}
\lstinputlisting[title=\texttt{matrix/functor2.cc}]{../ex7/matrix/functor2.cc}
\lstinputlisting[title=\texttt{matrix/functor3.cc}]{../ex7/matrix/functor3.cc}
\lstinputlisting[title=\texttt{matrix/operatorextract.cc}]{../ex7/matrix/operatorextract.cc}
\lstinputlisting[title=\texttt{matrix/operatorinsert.cc}]{../ex7/matrix/operatorinsert.cc}

\clearpage
\section*{Exercise 7}
\desc{Learn to implement and spot opportunities for overloaded operators}
\subsection*{1.}
The following two overloaded operators are added to compare two \texttt{Matrix} objects for (in)equality:
\lstinputlisting[title=\texttt{matrix/operatorequalto.cc}]{../ex7/matrix/operatorequalto.cc}
\lstinputlisting[title=\texttt{matrix/operatornotequalto.cc}]{../ex7/matrix/operatornotequalto.cc}
\subsection*{2.}
We modified the following code of the \texttt{Strings} class to facilitate comparing for (in)equality,
\lstinputlisting[title=\texttt{strings/strings.h}]{../ex7a/strings/strings.h}
\lstinputlisting[title=\texttt{strings/operatorequalto.cc}]{../ex7a/strings/operatorequalto.cc}
\lstinputlisting[title=\texttt{strings/operatornotequalto.cc}]{../ex7a/strings/operatornotequalto.cc}


\clearpage
\end{document}
